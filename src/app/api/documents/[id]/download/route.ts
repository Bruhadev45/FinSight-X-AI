import { NextRequest, NextResponse } from "next/server";
import { db } from "@/db";
import { documents } from "@/db/schema";
import { eq } from "drizzle-orm";
import { PDFDocument, rgb, StandardFonts } from "pdf-lib";
import fs from "fs";
import path from "path";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const docId = parseInt(id);

    if (isNaN(docId)) {
      return NextResponse.json(
        { error: "Invalid document ID" },
        { status: 400 }
      );
    }

    // Fetch document from database
    const [document] = await db
      .select()
      .from(documents)
      .where(eq(documents.id, docId))
      .limit(1);

    if (!document) {
      return NextResponse.json(
        { error: "Document not found" },
        { status: 404 }
      );
    }

    // If the file is already a PDF and exists in storage, serve it directly
    if (document.fileType === "pdf" && document.storagePath) {
      try {
        const filePath = path.join(process.cwd(), "public", document.storagePath);
        if (fs.existsSync(filePath)) {
          const fileBuffer = fs.readFileSync(filePath);
          return new NextResponse(fileBuffer, {
            headers: {
              "Content-Type": "application/pdf",
              "Content-Disposition": `attachment; filename="${document.fileName}"`,
            },
          });
        }
      } catch (error) {
        console.error("Error reading stored file:", error);
      }
    }

    // Generate a PDF report with document information
    const pdfDoc = await PDFDocument.create();
    const page = pdfDoc.addPage([595, 842]); // A4 size
    const { width, height } = page.getSize();
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

    let yPosition = height - 50;

    // Title
    page.drawText("FinSight X - Document Report", {
      x: 50,
      y: yPosition,
      size: 20,
      font: boldFont,
      color: rgb(0.2, 0.2, 0.5),
    });

    yPosition -= 40;

    // Document Information
    const infoItems = [
      { label: "File Name:", value: document.fileName },
      { label: "File Type:", value: document.fileType.toUpperCase() },
      { label: "File Size:", value: formatFileSize(document.fileSize) },
      { label: "Upload Date:", value: new Date(document.uploadDate).toLocaleString() },
      { label: "Status:", value: document.status },
      { label: "Risk Level:", value: document.riskLevel || "N/A" },
      { label: "Anomaly Count:", value: String(document.anomalyCount || 0) },
      { label: "Compliance Status:", value: document.complianceStatus || "N/A" },
    ];

    for (const item of infoItems) {
      page.drawText(item.label, {
        x: 50,
        y: yPosition,
        size: 12,
        font: boldFont,
        color: rgb(0.2, 0.2, 0.2),
      });

      page.drawText(item.value, {
        x: 200,
        y: yPosition,
        size: 12,
        font: font,
        color: rgb(0.3, 0.3, 0.3),
      });

      yPosition -= 25;
    }

    // Summary section
    if (document.summary) {
      yPosition -= 20;
      page.drawText("Summary:", {
        x: 50,
        y: yPosition,
        size: 14,
        font: boldFont,
        color: rgb(0.2, 0.2, 0.2),
      });

      yPosition -= 25;

      // Wrap text for summary
      const summaryLines = wrapText(document.summary, 80);
      for (const line of summaryLines) {
        if (yPosition < 50) break; // Prevent overflow
        page.drawText(line, {
          x: 50,
          y: yPosition,
          size: 11,
          font: font,
          color: rgb(0.3, 0.3, 0.3),
        });
        yPosition -= 18;
      }
    }

    // Footer
    page.drawText("Generated by FinSight X AI Financial Guardian", {
      x: 50,
      y: 30,
      size: 10,
      font: font,
      color: rgb(0.5, 0.5, 0.5),
    });

    page.drawText(new Date().toLocaleString(), {
      x: width - 200,
      y: 30,
      size: 10,
      font: font,
      color: rgb(0.5, 0.5, 0.5),
    });

    // Serialize the PDF
    const pdfBytes = await pdfDoc.save();

    // Return the PDF
    return new NextResponse(Buffer.from(pdfBytes), {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="${document.fileName.replace(/\.[^/.]+$/, "")}_report.pdf"`,
      },
    });
  } catch (error) {
    console.error("Error generating PDF:", error);
    return NextResponse.json(
      { error: "Failed to generate PDF" },
      { status: 500 }
    );
  }
}

function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
}

function wrapText(text: string, maxLength: number): string[] {
  const words = text.split(" ");
  const lines: string[] = [];
  let currentLine = "";

  for (const word of words) {
    if ((currentLine + word).length <= maxLength) {
      currentLine += (currentLine ? " " : "") + word;
    } else {
      if (currentLine) lines.push(currentLine);
      currentLine = word;
    }
  }

  if (currentLine) lines.push(currentLine);
  return lines;
}
